using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Runtime.InteropServices;
using System.Text;
using System.Xml.Linq;

namespace CreateSolution
{
    class proj
    {
        public string path;
        public string name;
        public string guid;
        public string assemblyname;
        public List<string> targets;
    };

    class Program
    {
        static void Main(string[] args)
        {
            // Make all string comparisons (and sort/order) invariant of current culture
            // Thus, solution output file is written in a consistent manner
            System.Threading.Thread.CurrentThread.CurrentCulture = System.Globalization.CultureInfo.InvariantCulture;

            string usage =
@"CreateSolution 1.4 - Creates VS solution file.

Usage: CreateSolution [-g] <path> <solutionfile> [-excludeprojs...]

-g: Generate global sections (autogenerated by VS, required by msbuild).

Example: CreateSolution . all.sln -myproj1 -myproj2";

            List<string> excludeprojects = new List<string>();

            for (int i = args.Length; i > 0; i--)
            {
                if (args[i - 1].StartsWith("-") && args[i - 1].Length >= 2)
                {
                    excludeprojects.Add(args[i - 1].Substring(1));
                }
                else
                {
                    break;
                }
            }


            if (args.Length - excludeprojects.Count == 2)
            {
                CreateSolution(args[0], args[1], false, excludeprojects);
            }
            else if (args.Length - excludeprojects.Count == 3 && args[0] == "-g")
            {
                CreateSolution(args[1], args[2], true, excludeprojects);
            }
            else
            {
                Console.WriteLine(usage);
            }
        }

        static void CreateSolution(string path, string solutionfile, bool generateGlobalSection, List<string> excludeprojects)
        {
            List<string> files;

            string[] exts = { ".csproj", ".vbproj", ".vcxproj" };
            string[] typeguids = {
                "FAE04EC0-301F-11D3-BF4B-00C04F79EFBC",
                "F184B08F-C81C-45F6-A57F-5ABD9991F28F",
                "8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942" };

            try
            {
                files = Directory.GetFiles(path, "*.*proj", SearchOption.AllDirectories)
                        .Where(filename => exts.Any(ext => Path.GetExtension(filename) == ext))
                        .ToList();
            }
            catch (DirectoryNotFoundException ex)
            {
                Console.WriteLine(ex.Message);
                return;
            }

            files.Sort();

            bool first = true;
            foreach (string filename in files.ToList())  // Create tmp list
            {
                if (excludeprojects.Any(p => exts.Any(ext => filename.EndsWith(@"\" + p + ext))))
                {
                    files.Remove(filename);
                    if (first)
                    {
                        Console.WriteLine("Excluding projects:");
                        first = false;
                    }
                    Console.WriteLine("  '" + filename + "'");
                }
            }


            IEnumerable<proj> projs = GetProjects(files, solutionfile);


            projs = RemoveDups(projs);


            int projcount = 0;

            StringBuilder sb = new StringBuilder();

            foreach (proj p in projs.OrderBy(p => p.name))
            {
                for (int i = 0; i < exts.Length; i++)
                {
                    if (Path.GetExtension(p.path) == exts[i])
                    {
                        sb.AppendLine(
                                "Project(\"{" + typeguids[i] + "}\") = \"" + p.name + "\", \"" + p.path + "\", \"" + p.guid + "\"" + Environment.NewLine +
                                "EndProject");
                    }
                }
                projcount++;
            }

            if (projcount < 1)
            {
                Console.WriteLine("Couldn't find any projects in: '" + path + "'");
                return;
            }


            if (generateGlobalSection)
            {
                // TODO: Analyze why this algorithm is different from VS,
                // it's noticeable on projects with more complex configs
                // than Debug & Release / AnyCPU.

                sb.AppendLine(
                        "Global" + Environment.NewLine +
                        "\tGlobalSection(SolutionConfigurationPlatforms) = preSolution");

                IEnumerable<string> targets = GetAllTargets(projs).OrderBy(t => t).Distinct();

                foreach (string target in targets)
                {
                    sb.AppendLine(
                            "\t\t" + target + "|Any CPU = " + target + "|Any CPU" + Environment.NewLine +
                            "\t\t" + target + "|Mixed Platforms = " + target + "|Mixed Platforms" + Environment.NewLine +
                            "\t\t" + target + "|x86 = " + target + "|x86");
                }

                sb.AppendLine(
                        "\tEndGlobalSection" + Environment.NewLine +
                        "\tGlobalSection(ProjectConfigurationPlatforms) = postSolution");

                foreach (proj p in projs.OrderBy(p => p.name))
                {
                    foreach (string target in p.targets)
                    {
                        sb.AppendLine(
                                "\t\t" + p.guid + "." + target + "|Any CPU.ActiveCfg = " + target + "|Any CPU" + Environment.NewLine +
                                "\t\t" + p.guid + "." + target + "|Any CPU.Build.0 = " + target + "|Any CPU" + Environment.NewLine +
                                "\t\t" + p.guid + "." + target + "|Mixed Platforms.ActiveCfg = " + target + "|Any CPU" + Environment.NewLine +
                                "\t\t" + p.guid + "." + target + "|Mixed Platforms.Build.0 = " + target + "|Any CPU" + Environment.NewLine +
                                "\t\t" + p.guid + "." + target + "|x86.ActiveCfg = " + target + "|Any CPU");
                    }
                }

                sb.AppendLine(
                        "\tEndGlobalSection" + Environment.NewLine +
                        "\tGlobalSection(SolutionProperties) = preSolution" + Environment.NewLine +
                        "\t\tHideSolutionNode = FALSE" + Environment.NewLine +
                        "\tEndGlobalSection" + Environment.NewLine +
                        "EndGlobal");
            }


            string s = sb.ToString();

            using (StreamWriter sw = new StreamWriter(solutionfile))
            {
                sw.Write(
                        "Microsoft Visual Studio Solution File, Format Version 11.00" + Environment.NewLine +
                        "# Visual Studio 2010" + Environment.NewLine +
                        s);
            }

            Console.WriteLine("Wrote " + projcount + " projects to " + solutionfile + ".");


            return;
        }

        static IEnumerable<proj> GetProjects(List<string> files, string solutionfile)
        {
            foreach (string file in files)
            {
                proj newproj;

                try
                {
                    XDocument xdoc = XDocument.Load(file);
                    XNamespace ns = xdoc.Root.Name.Namespace;

                    newproj = new proj();

                    try
                    {
                        newproj.guid = xdoc.Element(ns + "Project").Element(ns + "PropertyGroup").Element(ns + "ProjectGuid").Value.ToUpper();
                    }
                    catch (System.NullReferenceException)
                    {
                        Console.WriteLine("Couldn't load project: '" + file + "': Not a valid cs/vb/vc project file.");
                        continue;
                    }

                    XElement xele = xdoc.Element(ns + "Project").Element(ns + "PropertyGroup").Element(ns + "AssemblyName");
                    newproj.assemblyname = (xele == null) ? null : xele.Value;

                    newproj.name = Path.GetFileNameWithoutExtension(file);

                    string file1 = Path.GetFullPath(solutionfile);
                    string file2 = Path.GetFullPath(file);

                    string file3 = GetRelativePath(file1, file2);

                    newproj.path = file3;

                    try
                    {
                        newproj.targets =
                                (from el in xdoc.Element(ns + "Project").Elements(ns + "PropertyGroup")
                                 where el.Attribute("Condition") != null
                                 orderby GetTarget(el.Attribute("Condition").Value)
                                 select GetTarget(el.Attribute("Condition").Value)).ToList();
                    }
                    catch (System.NullReferenceException)
                    {
                        // No targets found
                        newproj.targets = new List<string>();
                    }
                }
                catch (System.Exception ex)
                {
                    Console.WriteLine("Couldn't load project: '" + file + "': " + ex.Message);
                    continue;
                }

                yield return newproj;
            }
        }

        private IEnumerable<proj> GetDuplicates(IEnumerable<proj> projs)
        {
            var results =
                    from proj a in projs
                    group a by a.guid into g
                    where g.Count() > 1
                    select g;

            foreach (var group in results)
            {
                foreach (var item in group)
                {
                    yield return item;
                }
            }
        }

        static IEnumerable<string> GetAllTargets(IEnumerable<proj> projs)
        {
            List<string> targets = new List<string>();

            foreach (proj p in projs)
            {
                foreach (string target in p.targets)
                {
                    targets.Add(target);
                }
            }

            IEnumerable<string> targets2 =
                    from t in targets
                    select t;

            List<string> targets3 = targets2.Distinct().ToList();

            List<string> targets4 = new List<string>();

            // Remove lowercase dups (keep most uppercased)
            foreach (string target in targets3)
            {
                bool add = true;
                foreach (string target2 in targets3)
                {
                    if (string.Compare(target, target2, StringComparison.InvariantCultureIgnoreCase) == 0 &&
                            string.Compare(target, target2) < 0)
                    {
                        add = false;
                        break;
                    }
                }
                if (add)
                {
                    targets4.Add(target);
                }
            }

            return targets4;
        }

        // " '$(Configuration)|$(Platform)' == 'Debug|AnyCPU' "
        // Debug
        static string GetTarget(string s)
        {
            int pos = s.IndexOf("==");
            if (pos < 0)
                throw new System.NullReferenceException();

            int pos2 = s.IndexOf("'", pos);
            if (pos2 < 0)
                throw new System.NullReferenceException();

            int pos3 = s.IndexOf("|", pos2);
            if (pos3 < 0)
                throw new System.NullReferenceException();

            return s.Substring(pos2 + 1, pos3 - pos2 - 1);
        }

        static IEnumerable<proj> RemoveDups(IEnumerable<proj> projs)
        {
            List<proj> projs2 = projs.ToList();

            int count;
            List<proj> projs3;
            bool first;



            projs3 = projs2.OrderBy(p => p.guid).ThenBy(pp => pp.path).ToList();
            first = true;
            foreach (proj p1 in projs3)
            {
                count = 0;
                foreach (proj p2 in projs2)
                {
                    if (p1.guid == p2.guid)
                    {
                        count++;
                    }
                }

                if (count > 1)
                {
                    if (first)
                    {
                        Console.WriteLine("Removing duplicate projects (by guid):");
                        first = false;
                    }

                    foreach (proj p2 in projs3)
                    {
                        if (p1.guid == p2.guid)
                        {
                            Console.WriteLine("  Guid: '" + p2.guid + "', File: '" + p2.path + "', Project: '" + p2.name + "'.");
                            projs2.Remove(p2);
                        }
                    }
                }
            }


            projs3 = projs2.OrderBy(p => p.guid).ThenBy(pp => pp.path).ToList();
            first = true;
            foreach (proj p1 in projs3)
            {
                count = 0;
                foreach (proj p2 in projs2)
                {
                    if (p1.assemblyname != null && p1.assemblyname.ToLower() == p2.assemblyname.ToLower())
                    {
                        count++;
                    }
                }

                if (count > 1)
                {
                    if (first)
                    {
                        Console.WriteLine("Removing duplicate projects (by assembly name):");
                        first = false;
                    }

                    foreach (proj p2 in projs3)
                    {
                        if (p1.assemblyname.ToLower() == p2.assemblyname.ToLower())
                        {
                            Console.WriteLine("  Assemblyname: '" + p2.assemblyname + "', File: '" + p2.path + "', Project: '" + p2.name + "'.");
                            projs2.Remove(p2);
                        }
                    }
                }
            }


            projs3 = projs2.OrderBy(p => p.name).ThenBy(pp => pp.path).ToList();
            first = true;
            foreach (proj p1 in projs3)
            {
                count = 0;
                foreach (proj p2 in projs2)
                {
                    if (p1.name.ToLower() == p2.name.ToLower())
                    {
                        count++;
                    }
                }

                if (count > 1)
                {
                    if (first)
                    {
                        Console.WriteLine("Removing duplicate projects (by file name):");
                        first = false;
                    }

                    foreach (proj p2 in projs3)
                    {
                        if (p1.name.ToLower() == p2.name.ToLower())
                        {
                            Console.WriteLine("  Project: '" + p2.name + "', File: '" + p2.path + "', Guid: '" + p2.guid + "'.");
                            projs2.Remove(p2);
                        }
                    }
                }
            }




            foreach (proj p in projs2)
            {
                if (p != null)
                {
                    yield return p;
                }
            }

        }

        static string GetRelativePath(string pathFrom, string pathTo)
        {
            string s = pathFrom;

            int pos = 0, dirs = 0;
            while (!pathTo.StartsWith(s) && s.Length > 0)
            {
                pos = s.LastIndexOf(Path.DirectorySeparatorChar);
                if (pos == -1)
                {
                    s = string.Empty;
                }
                else
                {
                    s = s.Substring(0, pos);
                }

                dirs++;
            }

            dirs--;

            string s2 = GetDirs(dirs);
            string s3 = pathTo.Substring(pos + 1);
            string s4 = s2 + s3;

            return s4;
        }

        static string GetDirs(int count)
        {
            StringBuilder sb = new StringBuilder();

            for (int i = 0; i < count; i++)
            {
                sb.Append(".." + Path.DirectorySeparatorChar);
            }

            return sb.ToString();
        }
    }
}
