using System;
using System.Collections.Generic;
using System.Globalization;
using System.IO;
using System.Linq;
using System.Security.Cryptography;
using System.Text;
using System.Threading;
using System.Xml.Linq;

namespace CreateSolution
{
    class Proj
    {
        public string path = string.Empty;
        public string name = string.Empty;
        public string guid = string.Empty;
        public string assemblyname = string.Empty;
        public List<string> targets = [];
    };

    class Program
    {
        enum VSVersion { VS2010, VS2012, VS2013, VS2015, VS2017, VS2019 };

        static void Main(string[] args)
        {
            ParseArguments(args);
            if (Environment.UserInteractive && string.IsNullOrEmpty(Environment.GetEnvironmentVariable("DontPrompt")))
            {
                Console.WriteLine("Press any key to continue...");
                _ = Console.ReadKey();
            }
        }

        static void ParseArguments(string[] args)
        {
            // Make all string comparisons (and sort/order) invariant of current culture
            // Thus, solution output file is written in a consistent manner
            Thread.CurrentThread.CurrentCulture = CultureInfo.InvariantCulture;

            var usage =
@"CreateSolution 2.4 - Creates VS solution file.

Usage: CreateSolution [-g] [-vX] [-wWebSiteFolder] <path> <solutionfile> [excludeprojs...]

-g: Generate global sections (autogenerated by VS, required by msbuild).
-v0: Generate VS2010 sln file.
-v2: Generate VS2012 sln file.
-v3: Generate VS2013 sln file.
-v5: Generate VS2015 sln file.
-v7: Generate VS2017 sln file.
-v9: Generate VS2019 sln file (default).

Example: CreateSolution -wSites\WebSite1 -wSites\WebSite2 . all.sln myproj1 myproj2";

            bool generateGlobalSection = false;
            VSVersion vsVersion = VSVersion.VS2019;
            List<string> websiteFolders = [];

            List<string> argsWithoutFlags = [];
            foreach (var arg in args)
            {
                switch (arg)
                {
                    case "-g":
                        generateGlobalSection = true;
                        break;
                    case "-v0":
                        vsVersion = VSVersion.VS2010;
                        break;
                    case "-v2":
                        vsVersion = VSVersion.VS2012;
                        break;
                    case "-v3":
                        vsVersion = VSVersion.VS2013;
                        break;
                    case "-v5":
                        vsVersion = VSVersion.VS2015;
                        break;
                    case "-v7":
                        vsVersion = VSVersion.VS2017;
                        break;
                    case "-v9":
                        vsVersion = VSVersion.VS2019;
                        break;
                    default:
                        if (arg.StartsWith("-w"))
                        {
                            websiteFolders.Add(arg[2..]);
                        }
                        else
                        {
                            argsWithoutFlags.Add(arg);
                        }
                        break;
                }
            }

            if (argsWithoutFlags.Count < 2)
            {
                Console.WriteLine(usage);
                return;
            }

            var path = argsWithoutFlags[0];
            var solutionfile = argsWithoutFlags[1];
            List<string> excludeProjects = [.. argsWithoutFlags.Skip(2)];

            CreateSolution(path, solutionfile, generateGlobalSection, vsVersion, excludeProjects, websiteFolders);
        }

        static void CreateSolution(string path, string solutionfile, bool generateGlobalSection, VSVersion vsVersion, List<string> excludeProjects, List<string> websiteFolders)
        {
            List<string> files;

            string[] exts = [".csproj", ".vbproj", ".vcxproj", ".sqlproj", ".modelproj"];
            string[] typeguids = [
                "FAE04EC0-301F-11D3-BF4B-00C04F79EFBC",  // maybe optional 9A19103F-16F7-4668-BE54-9A1E7A4F7556
                "F184B08F-C81C-45F6-A57F-5ABD9991F28F",
                "8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942",
                "00D1A9C2-B5F0-4AF3-8072-F6C62B433612",
                "F088123C-0E9E-452A-89E6-6BA2F21D5CAC" ];

            try
            {
                files = [.. Directory.GetFiles(path, "*.*proj", SearchOption.AllDirectories)
                    .Where(filename => exts.Any(ext => Path.GetExtension(filename) == ext))];
            }
            catch (DirectoryNotFoundException ex)
            {
                Console.WriteLine(ex.Message);
                return;
            }

            foreach (var websiteFolder in websiteFolders)
            {
                if (!Directory.Exists(websiteFolder))
                {
                    Console.WriteLine($"Website folder doesn't exist: '{websiteFolder}'");
                    return;
                }
            }

            Console.WriteLine($"Generating solution for: {vsVersion}");

            files.Sort();

            var first = true;
            foreach (var filename in files.ToList())  // Create tmp list
            {
                if (excludeProjects.Any(p => exts.Any(ext => filename.EndsWith($"\\{p}{ext}"))))
                {
                    _ = files.Remove(filename);
                    if (first)
                    {
                        Console.WriteLine("Excluding projects:");
                        first = false;
                    }
                    Console.WriteLine($"  '{filename}'");
                }
            }

            var projs = GetProjects(files, solutionfile);

            projs = RemoveDups(projs);

            var projcount = 0;

            StringBuilder sb = new();

            foreach (var p in projs.OrderBy(p => p.name))
            {
                for (var i = 0; i < exts.Length; i++)
                {
                    if (Path.GetExtension(p.path) == exts[i])
                    {
                        _ = sb.AppendLine("Project(\"{" + typeguids[i] + "}\") = \"" + $"{p.name}\", \"{p.path}\", \"{{{p.guid}}}\"{Environment.NewLine}EndProject");
                    }
                }
                projcount++;
            }

            foreach (var websiteFolder in websiteFolders)
            {
                int port;
                using var rng = RandomNumberGenerator.Create();
                var bytes = new byte[2];
                do
                {
                    rng.GetBytes(bytes);
                    port = BitConverter.ToUInt16(bytes, 0);
                } while (port is < 1024 or > 65535);

                _ = sb.AppendLine(
                    "Project(\"{E24C65DC-7377-472B-9ABA-BC803B73C61A}\") = \"" + $"{Path.GetFileName(websiteFolder)}\", \"http://localhost:{port}\", \"" + "{" + Guid.NewGuid().ToString().ToUpper() + "}" + $"\"{Environment.NewLine}" +
                    $"\tProjectSection(WebsiteProperties) = preProject{Environment.NewLine}" +
                    $"\t\tSlnRelativePath = \"{websiteFolder}\\\"{Environment.NewLine}" +
                    $"\tEndProjectSection{Environment.NewLine}" +
                    $"EndProject");
            }

            if (projcount == 0)
            {
                Console.WriteLine($"Couldn't find any projects in: '{path}'");
                return;
            }

            if (generateGlobalSection)
            {
                _ = sb.Append(GenerateGlobalSection(projs));
            }

            var s = vsVersion switch
            {
                VSVersion.VS2010 => $"Microsoft Visual Studio Solution File, Format Version 11.00{Environment.NewLine}# Visual Studio 2010{Environment.NewLine}{sb}",
                VSVersion.VS2012 => $"Microsoft Visual Studio Solution File, Format Version 12.00{Environment.NewLine}# Visual Studio 2012{Environment.NewLine}{sb}",
                VSVersion.VS2013 => $"Microsoft Visual Studio Solution File, Format Version 12.00{Environment.NewLine}# Visual Studio 2013{Environment.NewLine}{sb}",
                VSVersion.VS2015 => $"Microsoft Visual Studio Solution File, Format Version 12.00{Environment.NewLine}# Visual Studio 14{Environment.NewLine}{sb}",
                VSVersion.VS2017 => $"Microsoft Visual Studio Solution File, Format Version 12.00{Environment.NewLine}# Visual Studio 15{Environment.NewLine}{sb}",
                VSVersion.VS2019 => $"Microsoft Visual Studio Solution File, Format Version 12.00{Environment.NewLine}# Visual Studio Version 16{Environment.NewLine}{sb}",
                _ => throw new NotImplementedException()
            };

            Console.WriteLine($"Writing {projcount} projects to {solutionfile}.");
            using StreamWriter sw = new(solutionfile);
            sw.Write(s);
        }

        static List<Proj> GetProjects(List<string> files, string solutionfile)
        {
            List<Proj> projects = [];

            foreach (var filename in files)
            {
                Proj newproj;

                try
                {
                    var xdoc = XDocument.Load(filename);
                    if (xdoc == null || xdoc.Root == null)
                    {
                        Console.WriteLine($"Ignoring invalid project: '{filename}'");
                        continue;
                    }
                    var ns = xdoc.Root.Name.Namespace;

                    newproj = new Proj();

                    var file1 = Path.GetFullPath(solutionfile);
                    var file2 = Path.GetFullPath(filename);

                    var relpath = GetRelativePath(file1, file2);

                    newproj.path = relpath;

                    var guidelement = xdoc.Elements(ns + "Project").Elements(ns + "PropertyGroup").Elements(ns + "ProjectGuid").FirstOrDefault();
                    if (guidelement == null)
                    {
                        var pathbuf = Encoding.UTF8.GetBytes(relpath);
                        var filebuf = File.ReadAllBytes(filename);

                        var bytes = new byte[pathbuf.Length + filebuf.Length];
                        Buffer.BlockCopy(pathbuf, 0, bytes, 0, pathbuf.Length);
                        Buffer.BlockCopy(filebuf, 0, bytes, pathbuf.Length, filebuf.Length);

#pragma warning disable CA5351 // Generate a stable guid. guid and md5 is 128-bit, i.e. md5 is probably the best we can do.
                        var hash = MD5.HashData(bytes);
#pragma warning restore CA5351
                        Guid guid = new(hash);
                        newproj.guid = guid.ToString().ToUpper();
                    }
                    else
                    {
                        newproj.guid = guidelement.Value.ToUpper();
                    }

                    var xele = xdoc.Elements(ns + "Project").Elements(ns + "PropertyGroup").Elements(ns + "AssemblyName").FirstOrDefault();
                    if (xele == null)
                    {
                        Console.WriteLine($"Ignoring invalid project: '{filename}'");
                        continue;
                    }
                    newproj.assemblyname = xele.Value ?? string.Empty;
                    newproj.name = Path.GetFileNameWithoutExtension(filename);

                    try
                    {
                        newproj.targets = [.. xdoc
                            .Elements(ns + "Project").Elements(ns + "PropertyGroup")
                            .Where(el => el.Attribute("Condition") != null)
                            .OrderBy(el => GetTarget(el.Attribute("Condition")?.Value ?? string.Empty))
                            .Select(el => GetTarget(el.Attribute("Condition")?.Value ?? string.Empty))];
                    }
                    catch (NullReferenceException)
                    {
                        // No targets found
                    }
                }
                catch (Exception ex)
                {
                    Console.WriteLine($"Couldn't load project: '{filename}': {ex}");
                    continue;
                }

                projects.Add(newproj);
            }

            return projects;
        }

        static List<string> GetAllTargets(List<Proj> projs)
        {
            string[] targets = [.. projs.SelectMany(t => t.targets).Distinct()];

            // Remove lowercase dups (keep most uppercased)
            return [.. targets.Where(t => !targets.Any(tt => string.Compare(t, tt, StringComparison.OrdinalIgnoreCase) == 0 && string.Compare(t, tt) < 0))];
        }

        // " '$(Configuration)|$(Platform)' == 'Debug|AnyCPU' "
        // Debug
        static string GetTarget(string s)
        {
            var pos = s.IndexOf("==");
            if (pos < 0)
            {
                throw new NullReferenceException();
            }

            var pos2 = s.IndexOf('\'', pos);
            if (pos2 < 0)
            {
                throw new NullReferenceException();
            }

            var pos3 = s.IndexOf('|', pos2);

            return pos3 < 0 ? throw new NullReferenceException() : s.Substring(pos2 + 1, pos3 - pos2 - 1);
        }

        static List<Proj> RemoveDups(List<Proj> projs)
        {
            var projs2 = projs.ToList();  // Create tmp list

            RemoveByGuid(projs2);
            RemoveByAssemblyName(projs2);
            RemoveByFileName(projs2);

            return [.. projs2.Where(p => p != null)];
        }

        private static void RemoveByGuid(List<Proj> projs2)
        {
            List<Proj> projs3 = [.. projs2.OrderBy(p => p.guid).ThenBy(p => p.path)];  // Create tmp list
            var first = true;
            foreach (var proj1 in projs3)
            {
                var count = 0;
                foreach (var proj2 in projs2)
                {
                    if (proj1.guid == proj2.guid)
                    {
                        count++;
                    }
                }

                if (count > 1)
                {
                    if (first)
                    {
                        Console.WriteLine("Removing duplicate projects (by guid):");
                        first = false;
                    }

                    foreach (var proj2 in projs3)
                    {
                        if (proj1.guid == proj2.guid)
                        {
                            Console.WriteLine($"  Guid: '{proj2.guid}', File: '{proj2.path}', Project: '{proj2.name}'.");
                            _ = projs2.Remove(proj2);
                        }
                    }
                }
            }
        }

        private static void RemoveByAssemblyName(List<Proj> projs2)
        {
            List<Proj> projs3 = [.. projs2.OrderBy(p => p.assemblyname).ThenBy(p => p.path)];  // Create tmp list
            var first = true;
            foreach (var proj1 in projs3)
            {
                var count = 0;
                foreach (var proj2 in projs2)
                {
                    if (proj1.assemblyname != string.Empty && proj2.assemblyname != string.Empty && string.CompareOrdinal(proj1.assemblyname, proj2.assemblyname) == 0)
                    {
                        count++;
                    }
                }

                if (count > 1)
                {
                    if (first)
                    {
                        Console.WriteLine("Removing duplicate projects (by assembly name):");
                        first = false;
                    }

                    foreach (var proj2 in projs3)
                    {
                        if (proj1.assemblyname != string.Empty && proj2.assemblyname != string.Empty && string.CompareOrdinal(proj1.assemblyname, proj2.assemblyname) == 0)
                        {
                            Console.WriteLine($"  Assemblyname: '{proj2.assemblyname}', File: '{proj2.path}', Project: '{proj2.name}'.");
                            _ = projs2.Remove(proj2);
                        }
                    }
                }
            }
        }

        private static void RemoveByFileName(List<Proj> projs2)
        {
            List<Proj> projs3 = [.. projs2.OrderBy(p => p.name).ThenBy(p => p.path)];  // Create tmp list
            var first = true;
            foreach (var proj1 in projs3)
            {
                var count = 0;
                foreach (var proj2 in projs2)
                {
                    if (string.CompareOrdinal(proj1.name, proj2.name) == 0)
                    {
                        count++;
                    }
                }

                if (count > 1)
                {
                    if (first)
                    {
                        Console.WriteLine("Removing duplicate projects (by file name):");
                        first = false;
                    }

                    foreach (var proj2 in projs3)
                    {
                        if (string.CompareOrdinal(proj1.name, proj2.name) == 0)
                        {
                            Console.WriteLine($"  Project: '{proj2.name}', File: '{proj2.path}', Guid: '{proj2.guid}'.");
                            _ = projs2.Remove(proj2);
                        }
                    }
                }
            }
        }

        static string GetRelativePath(string pathFrom, string pathTo)
        {
            var s = pathFrom;

            int pos = 0, dirs = 0;
            while (!pathTo.StartsWith(s) && s.Length > 0)
            {
                pos = s.LastIndexOf(Path.DirectorySeparatorChar);
                s = pos == -1 ? string.Empty : s[..pos];
                dirs++;
            }

            dirs--;

            var s2 = string.Join(string.Empty, Enumerable.Repeat($"..{Path.DirectorySeparatorChar}", dirs));
            var s3 = pathTo[(pos + 1)..];
            var s4 = s2 + s3;

            return s4;
        }

        static string GenerateGlobalSection(List<Proj> projs)
        {
            // TODO: Analyze why this algorithm is different from VS,
            // it's noticeable on projects with more complex configs
            // than Debug & Release / AnyCPU.

            // A naive, simple algorithm was also wrong. :(

            var sb = new StringBuilder();

            _ = sb.AppendLine(
                $"Global{Environment.NewLine}" +
                $"\tGlobalSection(SolutionConfigurationPlatforms) = preSolution");

            string[] targets = [.. GetAllTargets(projs)
                .OrderBy(t => t)
                .Distinct()];

            foreach (var target in targets)
            {
                _ = sb.AppendLine(
                    $"\t\t{target}|Any CPU = {target}|Any CPU{Environment.NewLine}" +
                    $"\t\t{target}|Mixed Platforms = {target}|Mixed Platforms{Environment.NewLine}" +
                    $"\t\t{target}|x86 = {target}|x86");
            }

            _ = sb.AppendLine(
                $"\tEndGlobalSection{Environment.NewLine}" +
                $"\tGlobalSection(ProjectConfigurationPlatforms) = postSolution");

            foreach (var p in projs.OrderBy(p => p.name))
            {
                foreach (var target in p.targets)
                {
                    _ = sb.AppendLine(
                        $"\t\t{p.guid}.{target}|Any CPU.ActiveCfg = {target}|Any CPU{Environment.NewLine}" +
                        $"\t\t{p.guid}.{target}|Any CPU.Build.0 = {target}|Any CPU{Environment.NewLine}" +
                        $"\t\t{p.guid}.{target}|Mixed Platforms.ActiveCfg = {target}|Any CPU{Environment.NewLine}" +
                        $"\t\t{p.guid}.{target}|Mixed Platforms.Build.0 = {target}|Any CPU{Environment.NewLine}" +
                        $"\t\t{p.guid}.{target}|x86.ActiveCfg = {target}|Any CPU");
                }
            }

            _ = sb.AppendLine(
                $"\tEndGlobalSection{Environment.NewLine}" +
                $"\tGlobalSection(SolutionProperties) = preSolution{Environment.NewLine}" +
                $"\t\tHideSolutionNode = FALSE{Environment.NewLine}" +
                $"\tEndGlobalSection{Environment.NewLine}" +
                $"EndGlobal");

            return sb.ToString();
        }
    }
}
